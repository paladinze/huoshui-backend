module.exports = {
        typeDefs: // Code generated by Prisma (prisma@1.34.0). DO NOT EDIT.
  // Please don't change this file manually but run `prisma generate` to update it.
  // For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

/* GraphQL */ `type AggregateCourse {
  count: Int!
}

type Aggregateposition {
  count: Int!
}

type AggregateProf {
  count: Int!
}

type AggregateReview {
  count: Int!
}

type AggregateTag {
  count: Int!
}

type AggregateUser {
  count: Int!
}

type BatchPayload {
  count: Long!
}

type Course {
  id: ID!
  name: String!
  isElective: Boolean
  audience: String
}

type CourseConnection {
  pageInfo: PageInfo!
  edges: [CourseEdge]!
  aggregate: AggregateCourse!
}

input CourseCreateInput {
  id: ID
  name: String!
  isElective: Boolean
  audience: String
}

type CourseEdge {
  node: Course!
  cursor: String!
}

enum CourseOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  isElective_ASC
  isElective_DESC
  audience_ASC
  audience_DESC
}

type CoursePreviousValues {
  id: ID!
  name: String!
  isElective: Boolean
  audience: String
}

type CourseSubscriptionPayload {
  mutation: MutationType!
  node: Course
  updatedFields: [String!]
  previousValues: CoursePreviousValues
}

input CourseSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: CourseWhereInput
  AND: [CourseSubscriptionWhereInput!]
  OR: [CourseSubscriptionWhereInput!]
  NOT: [CourseSubscriptionWhereInput!]
}

input CourseUpdateInput {
  name: String
  isElective: Boolean
  audience: String
}

input CourseUpdateManyMutationInput {
  name: String
  isElective: Boolean
  audience: String
}

input CourseWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  isElective: Boolean
  isElective_not: Boolean
  audience: String
  audience_not: String
  audience_in: [String!]
  audience_not_in: [String!]
  audience_lt: String
  audience_lte: String
  audience_gt: String
  audience_gte: String
  audience_contains: String
  audience_not_contains: String
  audience_starts_with: String
  audience_not_starts_with: String
  audience_ends_with: String
  audience_not_ends_with: String
  AND: [CourseWhereInput!]
  OR: [CourseWhereInput!]
  NOT: [CourseWhereInput!]
}

input CourseWhereUniqueInput {
  id: ID
}

scalar DateTime

scalar Long

type Mutation {
  createCourse(data: CourseCreateInput!): Course!
  updateCourse(data: CourseUpdateInput!, where: CourseWhereUniqueInput!): Course
  updateManyCourses(data: CourseUpdateManyMutationInput!, where: CourseWhereInput): BatchPayload!
  upsertCourse(where: CourseWhereUniqueInput!, create: CourseCreateInput!, update: CourseUpdateInput!): Course!
  deleteCourse(where: CourseWhereUniqueInput!): Course
  deleteManyCourses(where: CourseWhereInput): BatchPayload!
  createProf(data: ProfCreateInput!): Prof!
  updateProf(data: ProfUpdateInput!, where: ProfWhereUniqueInput!): Prof
  updateManyProfs(data: ProfUpdateManyMutationInput!, where: ProfWhereInput): BatchPayload!
  upsertProf(where: ProfWhereUniqueInput!, create: ProfCreateInput!, update: ProfUpdateInput!): Prof!
  deleteProf(where: ProfWhereUniqueInput!): Prof
  deleteManyProfs(where: ProfWhereInput): BatchPayload!
  createReview(data: ReviewCreateInput!): Review!
  updateReview(data: ReviewUpdateInput!, where: ReviewWhereUniqueInput!): Review
  updateManyReviews(data: ReviewUpdateManyMutationInput!, where: ReviewWhereInput): BatchPayload!
  upsertReview(where: ReviewWhereUniqueInput!, create: ReviewCreateInput!, update: ReviewUpdateInput!): Review!
  deleteReview(where: ReviewWhereUniqueInput!): Review
  deleteManyReviews(where: ReviewWhereInput): BatchPayload!
  createTag(data: TagCreateInput!): Tag!
  updateTag(data: TagUpdateInput!, where: TagWhereUniqueInput!): Tag
  updateManyTags(data: TagUpdateManyMutationInput!, where: TagWhereInput): BatchPayload!
  upsertTag(where: TagWhereUniqueInput!, create: TagCreateInput!, update: TagUpdateInput!): Tag!
  deleteTag(where: TagWhereUniqueInput!): Tag
  deleteManyTags(where: TagWhereInput): BatchPayload!
  createUser(data: UserCreateInput!): User!
  updateUser(data: UserUpdateInput!, where: UserWhereUniqueInput!): User
  updateManyUsers(data: UserUpdateManyMutationInput!, where: UserWhereInput): BatchPayload!
  upsertUser(where: UserWhereUniqueInput!, create: UserCreateInput!, update: UserUpdateInput!): User!
  deleteUser(where: UserWhereUniqueInput!): User
  deleteManyUsers(where: UserWhereInput): BatchPayload!
  createposition(data: positionCreateInput!): position!
  updateposition(data: positionUpdateInput!, where: positionWhereUniqueInput!): position
  updateManypositions(data: positionUpdateManyMutationInput!, where: positionWhereInput): BatchPayload!
  upsertposition(where: positionWhereUniqueInput!, create: positionCreateInput!, update: positionUpdateInput!): position!
  deleteposition(where: positionWhereUniqueInput!): position
  deleteManypositions(where: positionWhereInput): BatchPayload!
}

enum MutationType {
  CREATED
  UPDATED
  DELETED
}

interface Node {
  id: ID!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}

type position {
  id: ID!
  name: String!
}

type positionConnection {
  pageInfo: PageInfo!
  edges: [positionEdge]!
  aggregate: Aggregateposition!
}

input positionCreateInput {
  id: ID
  name: String!
}

type positionEdge {
  node: position!
  cursor: String!
}

enum positionOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
}

type positionPreviousValues {
  id: ID!
  name: String!
}

type positionSubscriptionPayload {
  mutation: MutationType!
  node: position
  updatedFields: [String!]
  previousValues: positionPreviousValues
}

input positionSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: positionWhereInput
  AND: [positionSubscriptionWhereInput!]
  OR: [positionSubscriptionWhereInput!]
  NOT: [positionSubscriptionWhereInput!]
}

input positionUpdateInput {
  name: String
}

input positionUpdateManyMutationInput {
  name: String
}

input positionWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  AND: [positionWhereInput!]
  OR: [positionWhereInput!]
  NOT: [positionWhereInput!]
}

input positionWhereUniqueInput {
  id: ID
}

type Prof {
  name: ID!
  code: String!
  gender: Boolean
  birth: Int
  hometown: String
  motto: String
  email: String
  phone: String
  exp: Int
  researchGroup: String
  intro: String
  education: String
  research: String
  achievement: String
  scoreOverall: Float
  scoreProfessional: Float
  scoreExpressive: Float
  scoreKind: Float
  meanHomework: Float
  meanAttend: Float
  meanBirdy: Float
  meanExam: Float
  countReview: Int
  countGoodReview: Int
  countAverageReview: Int
  countBadReview: Int
  countHomework: Int
  countAttend: Int
  countBirdy: Int
  countExam: Int
  countExamDetails: Int
  countExamPrepYes: Int
  countExamPrepNo: Int
  countExamOpenbookYes: Int
  countExamOpenbookNo: Int
  countExamOldquestionYes: Int
  countExamOldquestionNo: Int
  countExamEasyYes: Int
  countExamEasyNo: Int
}

type ProfConnection {
  pageInfo: PageInfo!
  edges: [ProfEdge]!
  aggregate: AggregateProf!
}

input ProfCreateInput {
  name: ID
  code: String!
  gender: Boolean
  birth: Int
  hometown: String
  motto: String
  email: String
  phone: String
  exp: Int
  researchGroup: String
  intro: String
  education: String
  research: String
  achievement: String
  scoreOverall: Float
  scoreProfessional: Float
  scoreExpressive: Float
  scoreKind: Float
  meanHomework: Float
  meanAttend: Float
  meanBirdy: Float
  meanExam: Float
  countReview: Int
  countGoodReview: Int
  countAverageReview: Int
  countBadReview: Int
  countHomework: Int
  countAttend: Int
  countBirdy: Int
  countExam: Int
  countExamDetails: Int
  countExamPrepYes: Int
  countExamPrepNo: Int
  countExamOpenbookYes: Int
  countExamOpenbookNo: Int
  countExamOldquestionYes: Int
  countExamOldquestionNo: Int
  countExamEasyYes: Int
  countExamEasyNo: Int
}

type ProfEdge {
  node: Prof!
  cursor: String!
}

enum ProfOrderByInput {
  name_ASC
  name_DESC
  code_ASC
  code_DESC
  gender_ASC
  gender_DESC
  birth_ASC
  birth_DESC
  hometown_ASC
  hometown_DESC
  motto_ASC
  motto_DESC
  email_ASC
  email_DESC
  phone_ASC
  phone_DESC
  exp_ASC
  exp_DESC
  researchGroup_ASC
  researchGroup_DESC
  intro_ASC
  intro_DESC
  education_ASC
  education_DESC
  research_ASC
  research_DESC
  achievement_ASC
  achievement_DESC
  scoreOverall_ASC
  scoreOverall_DESC
  scoreProfessional_ASC
  scoreProfessional_DESC
  scoreExpressive_ASC
  scoreExpressive_DESC
  scoreKind_ASC
  scoreKind_DESC
  meanHomework_ASC
  meanHomework_DESC
  meanAttend_ASC
  meanAttend_DESC
  meanBirdy_ASC
  meanBirdy_DESC
  meanExam_ASC
  meanExam_DESC
  countReview_ASC
  countReview_DESC
  countGoodReview_ASC
  countGoodReview_DESC
  countAverageReview_ASC
  countAverageReview_DESC
  countBadReview_ASC
  countBadReview_DESC
  countHomework_ASC
  countHomework_DESC
  countAttend_ASC
  countAttend_DESC
  countBirdy_ASC
  countBirdy_DESC
  countExam_ASC
  countExam_DESC
  countExamDetails_ASC
  countExamDetails_DESC
  countExamPrepYes_ASC
  countExamPrepYes_DESC
  countExamPrepNo_ASC
  countExamPrepNo_DESC
  countExamOpenbookYes_ASC
  countExamOpenbookYes_DESC
  countExamOpenbookNo_ASC
  countExamOpenbookNo_DESC
  countExamOldquestionYes_ASC
  countExamOldquestionYes_DESC
  countExamOldquestionNo_ASC
  countExamOldquestionNo_DESC
  countExamEasyYes_ASC
  countExamEasyYes_DESC
  countExamEasyNo_ASC
  countExamEasyNo_DESC
}

type ProfPreviousValues {
  name: ID!
  code: String!
  gender: Boolean
  birth: Int
  hometown: String
  motto: String
  email: String
  phone: String
  exp: Int
  researchGroup: String
  intro: String
  education: String
  research: String
  achievement: String
  scoreOverall: Float
  scoreProfessional: Float
  scoreExpressive: Float
  scoreKind: Float
  meanHomework: Float
  meanAttend: Float
  meanBirdy: Float
  meanExam: Float
  countReview: Int
  countGoodReview: Int
  countAverageReview: Int
  countBadReview: Int
  countHomework: Int
  countAttend: Int
  countBirdy: Int
  countExam: Int
  countExamDetails: Int
  countExamPrepYes: Int
  countExamPrepNo: Int
  countExamOpenbookYes: Int
  countExamOpenbookNo: Int
  countExamOldquestionYes: Int
  countExamOldquestionNo: Int
  countExamEasyYes: Int
  countExamEasyNo: Int
}

type ProfSubscriptionPayload {
  mutation: MutationType!
  node: Prof
  updatedFields: [String!]
  previousValues: ProfPreviousValues
}

input ProfSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ProfWhereInput
  AND: [ProfSubscriptionWhereInput!]
  OR: [ProfSubscriptionWhereInput!]
  NOT: [ProfSubscriptionWhereInput!]
}

input ProfUpdateInput {
  code: String
  gender: Boolean
  birth: Int
  hometown: String
  motto: String
  email: String
  phone: String
  exp: Int
  researchGroup: String
  intro: String
  education: String
  research: String
  achievement: String
  scoreOverall: Float
  scoreProfessional: Float
  scoreExpressive: Float
  scoreKind: Float
  meanHomework: Float
  meanAttend: Float
  meanBirdy: Float
  meanExam: Float
  countReview: Int
  countGoodReview: Int
  countAverageReview: Int
  countBadReview: Int
  countHomework: Int
  countAttend: Int
  countBirdy: Int
  countExam: Int
  countExamDetails: Int
  countExamPrepYes: Int
  countExamPrepNo: Int
  countExamOpenbookYes: Int
  countExamOpenbookNo: Int
  countExamOldquestionYes: Int
  countExamOldquestionNo: Int
  countExamEasyYes: Int
  countExamEasyNo: Int
}

input ProfUpdateManyMutationInput {
  code: String
  gender: Boolean
  birth: Int
  hometown: String
  motto: String
  email: String
  phone: String
  exp: Int
  researchGroup: String
  intro: String
  education: String
  research: String
  achievement: String
  scoreOverall: Float
  scoreProfessional: Float
  scoreExpressive: Float
  scoreKind: Float
  meanHomework: Float
  meanAttend: Float
  meanBirdy: Float
  meanExam: Float
  countReview: Int
  countGoodReview: Int
  countAverageReview: Int
  countBadReview: Int
  countHomework: Int
  countAttend: Int
  countBirdy: Int
  countExam: Int
  countExamDetails: Int
  countExamPrepYes: Int
  countExamPrepNo: Int
  countExamOpenbookYes: Int
  countExamOpenbookNo: Int
  countExamOldquestionYes: Int
  countExamOldquestionNo: Int
  countExamEasyYes: Int
  countExamEasyNo: Int
}

input ProfWhereInput {
  name: ID
  name_not: ID
  name_in: [ID!]
  name_not_in: [ID!]
  name_lt: ID
  name_lte: ID
  name_gt: ID
  name_gte: ID
  name_contains: ID
  name_not_contains: ID
  name_starts_with: ID
  name_not_starts_with: ID
  name_ends_with: ID
  name_not_ends_with: ID
  code: String
  code_not: String
  code_in: [String!]
  code_not_in: [String!]
  code_lt: String
  code_lte: String
  code_gt: String
  code_gte: String
  code_contains: String
  code_not_contains: String
  code_starts_with: String
  code_not_starts_with: String
  code_ends_with: String
  code_not_ends_with: String
  gender: Boolean
  gender_not: Boolean
  birth: Int
  birth_not: Int
  birth_in: [Int!]
  birth_not_in: [Int!]
  birth_lt: Int
  birth_lte: Int
  birth_gt: Int
  birth_gte: Int
  hometown: String
  hometown_not: String
  hometown_in: [String!]
  hometown_not_in: [String!]
  hometown_lt: String
  hometown_lte: String
  hometown_gt: String
  hometown_gte: String
  hometown_contains: String
  hometown_not_contains: String
  hometown_starts_with: String
  hometown_not_starts_with: String
  hometown_ends_with: String
  hometown_not_ends_with: String
  motto: String
  motto_not: String
  motto_in: [String!]
  motto_not_in: [String!]
  motto_lt: String
  motto_lte: String
  motto_gt: String
  motto_gte: String
  motto_contains: String
  motto_not_contains: String
  motto_starts_with: String
  motto_not_starts_with: String
  motto_ends_with: String
  motto_not_ends_with: String
  email: String
  email_not: String
  email_in: [String!]
  email_not_in: [String!]
  email_lt: String
  email_lte: String
  email_gt: String
  email_gte: String
  email_contains: String
  email_not_contains: String
  email_starts_with: String
  email_not_starts_with: String
  email_ends_with: String
  email_not_ends_with: String
  phone: String
  phone_not: String
  phone_in: [String!]
  phone_not_in: [String!]
  phone_lt: String
  phone_lte: String
  phone_gt: String
  phone_gte: String
  phone_contains: String
  phone_not_contains: String
  phone_starts_with: String
  phone_not_starts_with: String
  phone_ends_with: String
  phone_not_ends_with: String
  exp: Int
  exp_not: Int
  exp_in: [Int!]
  exp_not_in: [Int!]
  exp_lt: Int
  exp_lte: Int
  exp_gt: Int
  exp_gte: Int
  researchGroup: String
  researchGroup_not: String
  researchGroup_in: [String!]
  researchGroup_not_in: [String!]
  researchGroup_lt: String
  researchGroup_lte: String
  researchGroup_gt: String
  researchGroup_gte: String
  researchGroup_contains: String
  researchGroup_not_contains: String
  researchGroup_starts_with: String
  researchGroup_not_starts_with: String
  researchGroup_ends_with: String
  researchGroup_not_ends_with: String
  intro: String
  intro_not: String
  intro_in: [String!]
  intro_not_in: [String!]
  intro_lt: String
  intro_lte: String
  intro_gt: String
  intro_gte: String
  intro_contains: String
  intro_not_contains: String
  intro_starts_with: String
  intro_not_starts_with: String
  intro_ends_with: String
  intro_not_ends_with: String
  education: String
  education_not: String
  education_in: [String!]
  education_not_in: [String!]
  education_lt: String
  education_lte: String
  education_gt: String
  education_gte: String
  education_contains: String
  education_not_contains: String
  education_starts_with: String
  education_not_starts_with: String
  education_ends_with: String
  education_not_ends_with: String
  research: String
  research_not: String
  research_in: [String!]
  research_not_in: [String!]
  research_lt: String
  research_lte: String
  research_gt: String
  research_gte: String
  research_contains: String
  research_not_contains: String
  research_starts_with: String
  research_not_starts_with: String
  research_ends_with: String
  research_not_ends_with: String
  achievement: String
  achievement_not: String
  achievement_in: [String!]
  achievement_not_in: [String!]
  achievement_lt: String
  achievement_lte: String
  achievement_gt: String
  achievement_gte: String
  achievement_contains: String
  achievement_not_contains: String
  achievement_starts_with: String
  achievement_not_starts_with: String
  achievement_ends_with: String
  achievement_not_ends_with: String
  scoreOverall: Float
  scoreOverall_not: Float
  scoreOverall_in: [Float!]
  scoreOverall_not_in: [Float!]
  scoreOverall_lt: Float
  scoreOverall_lte: Float
  scoreOverall_gt: Float
  scoreOverall_gte: Float
  scoreProfessional: Float
  scoreProfessional_not: Float
  scoreProfessional_in: [Float!]
  scoreProfessional_not_in: [Float!]
  scoreProfessional_lt: Float
  scoreProfessional_lte: Float
  scoreProfessional_gt: Float
  scoreProfessional_gte: Float
  scoreExpressive: Float
  scoreExpressive_not: Float
  scoreExpressive_in: [Float!]
  scoreExpressive_not_in: [Float!]
  scoreExpressive_lt: Float
  scoreExpressive_lte: Float
  scoreExpressive_gt: Float
  scoreExpressive_gte: Float
  scoreKind: Float
  scoreKind_not: Float
  scoreKind_in: [Float!]
  scoreKind_not_in: [Float!]
  scoreKind_lt: Float
  scoreKind_lte: Float
  scoreKind_gt: Float
  scoreKind_gte: Float
  meanHomework: Float
  meanHomework_not: Float
  meanHomework_in: [Float!]
  meanHomework_not_in: [Float!]
  meanHomework_lt: Float
  meanHomework_lte: Float
  meanHomework_gt: Float
  meanHomework_gte: Float
  meanAttend: Float
  meanAttend_not: Float
  meanAttend_in: [Float!]
  meanAttend_not_in: [Float!]
  meanAttend_lt: Float
  meanAttend_lte: Float
  meanAttend_gt: Float
  meanAttend_gte: Float
  meanBirdy: Float
  meanBirdy_not: Float
  meanBirdy_in: [Float!]
  meanBirdy_not_in: [Float!]
  meanBirdy_lt: Float
  meanBirdy_lte: Float
  meanBirdy_gt: Float
  meanBirdy_gte: Float
  meanExam: Float
  meanExam_not: Float
  meanExam_in: [Float!]
  meanExam_not_in: [Float!]
  meanExam_lt: Float
  meanExam_lte: Float
  meanExam_gt: Float
  meanExam_gte: Float
  countReview: Int
  countReview_not: Int
  countReview_in: [Int!]
  countReview_not_in: [Int!]
  countReview_lt: Int
  countReview_lte: Int
  countReview_gt: Int
  countReview_gte: Int
  countGoodReview: Int
  countGoodReview_not: Int
  countGoodReview_in: [Int!]
  countGoodReview_not_in: [Int!]
  countGoodReview_lt: Int
  countGoodReview_lte: Int
  countGoodReview_gt: Int
  countGoodReview_gte: Int
  countAverageReview: Int
  countAverageReview_not: Int
  countAverageReview_in: [Int!]
  countAverageReview_not_in: [Int!]
  countAverageReview_lt: Int
  countAverageReview_lte: Int
  countAverageReview_gt: Int
  countAverageReview_gte: Int
  countBadReview: Int
  countBadReview_not: Int
  countBadReview_in: [Int!]
  countBadReview_not_in: [Int!]
  countBadReview_lt: Int
  countBadReview_lte: Int
  countBadReview_gt: Int
  countBadReview_gte: Int
  countHomework: Int
  countHomework_not: Int
  countHomework_in: [Int!]
  countHomework_not_in: [Int!]
  countHomework_lt: Int
  countHomework_lte: Int
  countHomework_gt: Int
  countHomework_gte: Int
  countAttend: Int
  countAttend_not: Int
  countAttend_in: [Int!]
  countAttend_not_in: [Int!]
  countAttend_lt: Int
  countAttend_lte: Int
  countAttend_gt: Int
  countAttend_gte: Int
  countBirdy: Int
  countBirdy_not: Int
  countBirdy_in: [Int!]
  countBirdy_not_in: [Int!]
  countBirdy_lt: Int
  countBirdy_lte: Int
  countBirdy_gt: Int
  countBirdy_gte: Int
  countExam: Int
  countExam_not: Int
  countExam_in: [Int!]
  countExam_not_in: [Int!]
  countExam_lt: Int
  countExam_lte: Int
  countExam_gt: Int
  countExam_gte: Int
  countExamDetails: Int
  countExamDetails_not: Int
  countExamDetails_in: [Int!]
  countExamDetails_not_in: [Int!]
  countExamDetails_lt: Int
  countExamDetails_lte: Int
  countExamDetails_gt: Int
  countExamDetails_gte: Int
  countExamPrepYes: Int
  countExamPrepYes_not: Int
  countExamPrepYes_in: [Int!]
  countExamPrepYes_not_in: [Int!]
  countExamPrepYes_lt: Int
  countExamPrepYes_lte: Int
  countExamPrepYes_gt: Int
  countExamPrepYes_gte: Int
  countExamPrepNo: Int
  countExamPrepNo_not: Int
  countExamPrepNo_in: [Int!]
  countExamPrepNo_not_in: [Int!]
  countExamPrepNo_lt: Int
  countExamPrepNo_lte: Int
  countExamPrepNo_gt: Int
  countExamPrepNo_gte: Int
  countExamOpenbookYes: Int
  countExamOpenbookYes_not: Int
  countExamOpenbookYes_in: [Int!]
  countExamOpenbookYes_not_in: [Int!]
  countExamOpenbookYes_lt: Int
  countExamOpenbookYes_lte: Int
  countExamOpenbookYes_gt: Int
  countExamOpenbookYes_gte: Int
  countExamOpenbookNo: Int
  countExamOpenbookNo_not: Int
  countExamOpenbookNo_in: [Int!]
  countExamOpenbookNo_not_in: [Int!]
  countExamOpenbookNo_lt: Int
  countExamOpenbookNo_lte: Int
  countExamOpenbookNo_gt: Int
  countExamOpenbookNo_gte: Int
  countExamOldquestionYes: Int
  countExamOldquestionYes_not: Int
  countExamOldquestionYes_in: [Int!]
  countExamOldquestionYes_not_in: [Int!]
  countExamOldquestionYes_lt: Int
  countExamOldquestionYes_lte: Int
  countExamOldquestionYes_gt: Int
  countExamOldquestionYes_gte: Int
  countExamOldquestionNo: Int
  countExamOldquestionNo_not: Int
  countExamOldquestionNo_in: [Int!]
  countExamOldquestionNo_not_in: [Int!]
  countExamOldquestionNo_lt: Int
  countExamOldquestionNo_lte: Int
  countExamOldquestionNo_gt: Int
  countExamOldquestionNo_gte: Int
  countExamEasyYes: Int
  countExamEasyYes_not: Int
  countExamEasyYes_in: [Int!]
  countExamEasyYes_not_in: [Int!]
  countExamEasyYes_lt: Int
  countExamEasyYes_lte: Int
  countExamEasyYes_gt: Int
  countExamEasyYes_gte: Int
  countExamEasyNo: Int
  countExamEasyNo_not: Int
  countExamEasyNo_in: [Int!]
  countExamEasyNo_not_in: [Int!]
  countExamEasyNo_lt: Int
  countExamEasyNo_lte: Int
  countExamEasyNo_gt: Int
  countExamEasyNo_gte: Int
  AND: [ProfWhereInput!]
  OR: [ProfWhereInput!]
  NOT: [ProfWhereInput!]
}

input ProfWhereUniqueInput {
  name: ID
}

type Query {
  course(where: CourseWhereUniqueInput!): Course
  courses(where: CourseWhereInput, orderBy: CourseOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Course]!
  coursesConnection(where: CourseWhereInput, orderBy: CourseOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): CourseConnection!
  prof(where: ProfWhereUniqueInput!): Prof
  profs(where: ProfWhereInput, orderBy: ProfOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Prof]!
  profsConnection(where: ProfWhereInput, orderBy: ProfOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ProfConnection!
  review(where: ReviewWhereUniqueInput!): Review
  reviews(where: ReviewWhereInput, orderBy: ReviewOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Review]!
  reviewsConnection(where: ReviewWhereInput, orderBy: ReviewOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ReviewConnection!
  tag(where: TagWhereUniqueInput!): Tag
  tags(where: TagWhereInput, orderBy: TagOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Tag]!
  tagsConnection(where: TagWhereInput, orderBy: TagOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): TagConnection!
  user(where: UserWhereUniqueInput!): User
  users(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [User]!
  usersConnection(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): UserConnection!
  position(where: positionWhereUniqueInput!): position
  positions(where: positionWhereInput, orderBy: positionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [position]!
  positionsConnection(where: positionWhereInput, orderBy: positionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): positionConnection!
  node(id: ID!): Node
}

type Review {
  id: ID!
  text: String!
  upVote: Int!
  downVote: Int!
  author: User!
}

type ReviewConnection {
  pageInfo: PageInfo!
  edges: [ReviewEdge]!
  aggregate: AggregateReview!
}

input ReviewCreateInput {
  id: ID
  text: String!
  upVote: Int!
  downVote: Int!
  author: UserCreateOneWithoutReviewsInput!
}

input ReviewCreateManyInput {
  create: [ReviewCreateInput!]
  connect: [ReviewWhereUniqueInput!]
}

input ReviewCreateManyWithoutAuthorInput {
  create: [ReviewCreateWithoutAuthorInput!]
  connect: [ReviewWhereUniqueInput!]
}

input ReviewCreateWithoutAuthorInput {
  id: ID
  text: String!
  upVote: Int!
  downVote: Int!
}

type ReviewEdge {
  node: Review!
  cursor: String!
}

enum ReviewOrderByInput {
  id_ASC
  id_DESC
  text_ASC
  text_DESC
  upVote_ASC
  upVote_DESC
  downVote_ASC
  downVote_DESC
}

type ReviewPreviousValues {
  id: ID!
  text: String!
  upVote: Int!
  downVote: Int!
}

input ReviewScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  text: String
  text_not: String
  text_in: [String!]
  text_not_in: [String!]
  text_lt: String
  text_lte: String
  text_gt: String
  text_gte: String
  text_contains: String
  text_not_contains: String
  text_starts_with: String
  text_not_starts_with: String
  text_ends_with: String
  text_not_ends_with: String
  upVote: Int
  upVote_not: Int
  upVote_in: [Int!]
  upVote_not_in: [Int!]
  upVote_lt: Int
  upVote_lte: Int
  upVote_gt: Int
  upVote_gte: Int
  downVote: Int
  downVote_not: Int
  downVote_in: [Int!]
  downVote_not_in: [Int!]
  downVote_lt: Int
  downVote_lte: Int
  downVote_gt: Int
  downVote_gte: Int
  AND: [ReviewScalarWhereInput!]
  OR: [ReviewScalarWhereInput!]
  NOT: [ReviewScalarWhereInput!]
}

type ReviewSubscriptionPayload {
  mutation: MutationType!
  node: Review
  updatedFields: [String!]
  previousValues: ReviewPreviousValues
}

input ReviewSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ReviewWhereInput
  AND: [ReviewSubscriptionWhereInput!]
  OR: [ReviewSubscriptionWhereInput!]
  NOT: [ReviewSubscriptionWhereInput!]
}

input ReviewUpdateDataInput {
  text: String
  upVote: Int
  downVote: Int
  author: UserUpdateOneRequiredWithoutReviewsInput
}

input ReviewUpdateInput {
  text: String
  upVote: Int
  downVote: Int
  author: UserUpdateOneRequiredWithoutReviewsInput
}

input ReviewUpdateManyDataInput {
  text: String
  upVote: Int
  downVote: Int
}

input ReviewUpdateManyInput {
  create: [ReviewCreateInput!]
  update: [ReviewUpdateWithWhereUniqueNestedInput!]
  upsert: [ReviewUpsertWithWhereUniqueNestedInput!]
  delete: [ReviewWhereUniqueInput!]
  connect: [ReviewWhereUniqueInput!]
  set: [ReviewWhereUniqueInput!]
  disconnect: [ReviewWhereUniqueInput!]
  deleteMany: [ReviewScalarWhereInput!]
  updateMany: [ReviewUpdateManyWithWhereNestedInput!]
}

input ReviewUpdateManyMutationInput {
  text: String
  upVote: Int
  downVote: Int
}

input ReviewUpdateManyWithoutAuthorInput {
  create: [ReviewCreateWithoutAuthorInput!]
  delete: [ReviewWhereUniqueInput!]
  connect: [ReviewWhereUniqueInput!]
  set: [ReviewWhereUniqueInput!]
  disconnect: [ReviewWhereUniqueInput!]
  update: [ReviewUpdateWithWhereUniqueWithoutAuthorInput!]
  upsert: [ReviewUpsertWithWhereUniqueWithoutAuthorInput!]
  deleteMany: [ReviewScalarWhereInput!]
  updateMany: [ReviewUpdateManyWithWhereNestedInput!]
}

input ReviewUpdateManyWithWhereNestedInput {
  where: ReviewScalarWhereInput!
  data: ReviewUpdateManyDataInput!
}

input ReviewUpdateWithoutAuthorDataInput {
  text: String
  upVote: Int
  downVote: Int
}

input ReviewUpdateWithWhereUniqueNestedInput {
  where: ReviewWhereUniqueInput!
  data: ReviewUpdateDataInput!
}

input ReviewUpdateWithWhereUniqueWithoutAuthorInput {
  where: ReviewWhereUniqueInput!
  data: ReviewUpdateWithoutAuthorDataInput!
}

input ReviewUpsertWithWhereUniqueNestedInput {
  where: ReviewWhereUniqueInput!
  update: ReviewUpdateDataInput!
  create: ReviewCreateInput!
}

input ReviewUpsertWithWhereUniqueWithoutAuthorInput {
  where: ReviewWhereUniqueInput!
  update: ReviewUpdateWithoutAuthorDataInput!
  create: ReviewCreateWithoutAuthorInput!
}

input ReviewWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  text: String
  text_not: String
  text_in: [String!]
  text_not_in: [String!]
  text_lt: String
  text_lte: String
  text_gt: String
  text_gte: String
  text_contains: String
  text_not_contains: String
  text_starts_with: String
  text_not_starts_with: String
  text_ends_with: String
  text_not_ends_with: String
  upVote: Int
  upVote_not: Int
  upVote_in: [Int!]
  upVote_not_in: [Int!]
  upVote_lt: Int
  upVote_lte: Int
  upVote_gt: Int
  upVote_gte: Int
  downVote: Int
  downVote_not: Int
  downVote_in: [Int!]
  downVote_not_in: [Int!]
  downVote_lt: Int
  downVote_lte: Int
  downVote_gt: Int
  downVote_gte: Int
  author: UserWhereInput
  AND: [ReviewWhereInput!]
  OR: [ReviewWhereInput!]
  NOT: [ReviewWhereInput!]
}

input ReviewWhereUniqueInput {
  id: ID
}

type Subscription {
  course(where: CourseSubscriptionWhereInput): CourseSubscriptionPayload
  prof(where: ProfSubscriptionWhereInput): ProfSubscriptionPayload
  review(where: ReviewSubscriptionWhereInput): ReviewSubscriptionPayload
  tag(where: TagSubscriptionWhereInput): TagSubscriptionPayload
  user(where: UserSubscriptionWhereInput): UserSubscriptionPayload
  position(where: positionSubscriptionWhereInput): positionSubscriptionPayload
}

type Tag {
  id: ID!
  name: String!
  isPositive: Boolean!
  category: String
}

type TagConnection {
  pageInfo: PageInfo!
  edges: [TagEdge]!
  aggregate: AggregateTag!
}

input TagCreateInput {
  id: ID
  name: String!
  isPositive: Boolean!
  category: String
}

type TagEdge {
  node: Tag!
  cursor: String!
}

enum TagOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  isPositive_ASC
  isPositive_DESC
  category_ASC
  category_DESC
}

type TagPreviousValues {
  id: ID!
  name: String!
  isPositive: Boolean!
  category: String
}

type TagSubscriptionPayload {
  mutation: MutationType!
  node: Tag
  updatedFields: [String!]
  previousValues: TagPreviousValues
}

input TagSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: TagWhereInput
  AND: [TagSubscriptionWhereInput!]
  OR: [TagSubscriptionWhereInput!]
  NOT: [TagSubscriptionWhereInput!]
}

input TagUpdateInput {
  name: String
  isPositive: Boolean
  category: String
}

input TagUpdateManyMutationInput {
  name: String
  isPositive: Boolean
  category: String
}

input TagWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  isPositive: Boolean
  isPositive_not: Boolean
  category: String
  category_not: String
  category_in: [String!]
  category_not_in: [String!]
  category_lt: String
  category_lte: String
  category_gt: String
  category_gte: String
  category_contains: String
  category_not_contains: String
  category_starts_with: String
  category_not_starts_with: String
  category_ends_with: String
  category_not_ends_with: String
  AND: [TagWhereInput!]
  OR: [TagWhereInput!]
  NOT: [TagWhereInput!]
}

input TagWhereUniqueInput {
  id: ID
}

type User {
  id: ID!
  username: String!
  email: String!
  password: String!
  updatedAt: DateTime!
  createdAt: DateTime!
  reviews(where: ReviewWhereInput, orderBy: ReviewOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Review!]
  likedReviews(where: ReviewWhereInput, orderBy: ReviewOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Review!]
}

type UserConnection {
  pageInfo: PageInfo!
  edges: [UserEdge]!
  aggregate: AggregateUser!
}

input UserCreateInput {
  id: ID
  username: String!
  email: String!
  password: String!
  reviews: ReviewCreateManyWithoutAuthorInput
  likedReviews: ReviewCreateManyInput
}

input UserCreateOneWithoutReviewsInput {
  create: UserCreateWithoutReviewsInput
  connect: UserWhereUniqueInput
}

input UserCreateWithoutReviewsInput {
  id: ID
  username: String!
  email: String!
  password: String!
  likedReviews: ReviewCreateManyInput
}

type UserEdge {
  node: User!
  cursor: String!
}

enum UserOrderByInput {
  id_ASC
  id_DESC
  username_ASC
  username_DESC
  email_ASC
  email_DESC
  password_ASC
  password_DESC
  updatedAt_ASC
  updatedAt_DESC
  createdAt_ASC
  createdAt_DESC
}

type UserPreviousValues {
  id: ID!
  username: String!
  email: String!
  password: String!
  updatedAt: DateTime!
  createdAt: DateTime!
}

type UserSubscriptionPayload {
  mutation: MutationType!
  node: User
  updatedFields: [String!]
  previousValues: UserPreviousValues
}

input UserSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: UserWhereInput
  AND: [UserSubscriptionWhereInput!]
  OR: [UserSubscriptionWhereInput!]
  NOT: [UserSubscriptionWhereInput!]
}

input UserUpdateInput {
  username: String
  email: String
  password: String
  reviews: ReviewUpdateManyWithoutAuthorInput
  likedReviews: ReviewUpdateManyInput
}

input UserUpdateManyMutationInput {
  username: String
  email: String
  password: String
}

input UserUpdateOneRequiredWithoutReviewsInput {
  create: UserCreateWithoutReviewsInput
  update: UserUpdateWithoutReviewsDataInput
  upsert: UserUpsertWithoutReviewsInput
  connect: UserWhereUniqueInput
}

input UserUpdateWithoutReviewsDataInput {
  username: String
  email: String
  password: String
  likedReviews: ReviewUpdateManyInput
}

input UserUpsertWithoutReviewsInput {
  update: UserUpdateWithoutReviewsDataInput!
  create: UserCreateWithoutReviewsInput!
}

input UserWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  username: String
  username_not: String
  username_in: [String!]
  username_not_in: [String!]
  username_lt: String
  username_lte: String
  username_gt: String
  username_gte: String
  username_contains: String
  username_not_contains: String
  username_starts_with: String
  username_not_starts_with: String
  username_ends_with: String
  username_not_ends_with: String
  email: String
  email_not: String
  email_in: [String!]
  email_not_in: [String!]
  email_lt: String
  email_lte: String
  email_gt: String
  email_gte: String
  email_contains: String
  email_not_contains: String
  email_starts_with: String
  email_not_starts_with: String
  email_ends_with: String
  email_not_ends_with: String
  password: String
  password_not: String
  password_in: [String!]
  password_not_in: [String!]
  password_lt: String
  password_lte: String
  password_gt: String
  password_gte: String
  password_contains: String
  password_not_contains: String
  password_starts_with: String
  password_not_starts_with: String
  password_ends_with: String
  password_not_ends_with: String
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  reviews_every: ReviewWhereInput
  reviews_some: ReviewWhereInput
  reviews_none: ReviewWhereInput
  likedReviews_every: ReviewWhereInput
  likedReviews_some: ReviewWhereInput
  likedReviews_none: ReviewWhereInput
  AND: [UserWhereInput!]
  OR: [UserWhereInput!]
  NOT: [UserWhereInput!]
}

input UserWhereUniqueInput {
  id: ID
  username: String
  email: String
}
`
      }
    